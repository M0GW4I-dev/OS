# メモリーマップ
0x00000000  ┌──────────────────
            │割り込みベクタテーブル
0x00000400  ├──────────────────
            │BIOSデータ
0x00000500  ├──────────────────
            │未使用
0x00007c00  ├──────────────────
            │ブートローダ
0x00007e00  ├──────────────────
            │未使用
0x000A0000  ├──────────────────
            │VRAM(ビデオメモリ)
0x000B0000  ├──────────────────
            │VRAM(モノクロ)
0x000B8000  ├──────────────────
            │VRAM(カラー)
0x000C0000  ├──────────────────
            │BIOS Video関連
0x000F0000  ├──────────────────
            │BIOS 予備
0x00100000  ├──────────────────
            │BIOS
0x00000000  └──────────────────

# protected mode
* 保護モード
* 32 bit で動作
* 仮想メモリ
* メモリの扱いの変更
* 4 GBまで使用可能
* BIOSの処理が使用不可

# メモリアクセスについて
セグメントレジスタとGDTを用いてメモリアクセス
それぞれのセグメントレジスタはセグメントディスクリプタを表すGDTが始まるアドレスからのオフセットが入る

## GDT
┌────────────────────────────────────
│Segment Discriptor(64 bit)
├────────────────────────────────────
│...
├────────────────────────────────────

## 論理アドレスとリニアアドレス
論理アドレスは、[セグメントセレクタの値:オフセット]になる
実アドレスは、セグメントセレクタの値で指定されたセグメントディスクリプタのbaseaddressに加算したもの
プログラム中に明示的にセグメントレジスタを指定しなければ、DSかSSレジスタを使う

## 特権レベル
リング0 ~ リング3 がある
リング0 は、特権レベルが高い
リング3 は、特権レベルが低い

## セグメントセレクタ
[セグメントセレクタ:オフセット]で論理アドレスを指定した時、セグメントセレクタは
セグメントセレクタは3~15bit目がセグメントディスクリプタを表すindexで、2bit目は、テーブルインジケータ、0~1bit目は、RPL(Requested Privilege Level)を表す。

# プロテクテッドモードへの移行
32bit のCR0レジスタのPEbitを 1 にする
protected mode に移動した直後に、

```
movl $0x08, %cs
movl $0x10, %ds
```

は動作しない。

# Grub
## カーネル移行時のマシン状態
* %eax: マジックナンバー 0x2badb002 を格納
* %ebx: マルチブート情報を格納しているアドレス
* %cs: この時点で、既にGDTは構築済みで、コードセグメントを洗濯した状態になっている
* %DS, %ES, %Fs, %GS, %SS: ローダが構築したデータセグメントになっている
* A20ゲート: 既に有効になっている
* CR0: ページングは無効で、protected mode に移行済み
* その他: 未定義

## マルチブート情報
GrubがBIOSから取得したメモリーマップの情報をカーネルに渡してくれる
構造体の内容(かっこ内はflagsの何ビット目に依存しているか

offset(byte)
0   ┌──────────────────
    │flags(必須)
4   ├──────────────────
    │mem_lower(flags(0))
8   ├──────────────────
    │mem_upper(flags(0))
12  ├──────────────────
    │boot_device(flags(1))
16  ├──────────────────
    │cmdline(flags(2))
20  ├──────────────────
    │mods_count(flags(3))
24  ├──────────────────
    │mods_addr(flags(3))
28  ├──────────────────
    │...
40  ├──────────────────
    │syms(flags(4) or flags(5))
44  ├──────────────────
    │mmap_length(flags(6))
48  ├──────────────────
    │mmap_addr(flags(6))
52  ├──────────────────
    │drives_length(flags(7))
56  ├──────────────────
    │drives_addr(flags(7))
60  ├──────────────────
    │config_table(flags(8))
64  ├──────────────────
    │boot_loader_name(flags(9))
68  ├──────────────────
    │apm_table(flags(10))
72  ├──────────────────
    │vbe_control_info(flags(11))
76  ├──────────────────
    │vbe_control_info(flags(11))
80  ├──────────────────
    │vbe_mode_info
82  ├──────────────────
    │vbe_mode
84  ├──────────────────
    │vbe_interface_seg
86  ├──────────────────
    │vbe_interface_off
86  ├──────────────────
    │vbe_interface_len
    └──────────────────

# ビデオドライバ

## VGA
VGAの構成要素
- ビデオバッファ
- ビデオDAC
- CRT(Cathode Ray Tube)コントローラ
- シーケンサ
- グラフィックコントローラ
- アトリビュートコントローラ

## ビデオバッファ
ビデオバッファはビデオメモリ(VRAM)として、メモリ上にマップされている。
起動時に、BIOSが0x000A0000にマップする。

## ビデオDAC
カラーパレットを参照して、デジタル信号をアナログの色信号に変換する。

## CRTコントローラ
水平同期信号タイミング、垂直同期信号タイミング、カーソルタイミング、アンダーラインタイミングを生成する。

## シーケンサ
VRAMにアクセスするために、メモリタイミングとVRAMからデータを読み出すキャラクタタイミングを生成する。

## アトリビュートコントローラ
ブリンク、アンダーライン、カーソル移動などをアトリビュートコントローラが制御する。

## ビデオモード
グラフィックモードとテキストモードがある。

カラーディスプレイのデフォルトのビデオモードは3+
モノクロディスプレイのデフォルトのビデオモードは7+

0x000A0000 - 0x000AFFFF はグラフィックモードで使用する
0x000B0000 - 0x000B7FFF はモノクロテキストモード
0x000B8000 - 0x000BFFFF はカラーテキストモード

アトリビュートのビットアサイン
0-2 0-Blue 1-Green 2-Red
3-3 アトリビュートモード制御レジスタ(I/Oアドレス:0x03C0-0x03C1)の設定によって文字の明度を変えるか文字のフォントを変えるかの機能が変わる
4-6 バックグラウンドカラー 4-Blue 5-Green 6-Red
7-7 文字のブリンク指定か背景色の明度を変える

# 割り込み

## 割り込みの種類
- 例外 (Exception)
- 割り込み要求 (IRQ)
- ソフトウェア割り込み

## 割り込み要求
CPUの周辺にあるハードウェアから要求が会った時に発生する信号

## ソフトウェア割り込み
int 命令で発生する割り込み

# IDT(Interrupt Descriptor Table)
IDTは割り込みと割り込みハンドラを結びつけるテーブル。
ディスクリプタは、3 種類のディスクリプタがある。

- タスクゲートディスクリプタ(タスクスイッチに使用)
- 割り込みゲートディスクリプタ(割り込みを受けたら他の割り込みはマスクする)
- トラップゲートディスクリプタ

## 8259Aの操作コマンド
初期設定が終わると、PICは割り込みを受け付けるようになり、通常動作する。
通常動作時にPICを制御するコマンドをOCW(Operation Command Words)と言う。

### OCW1
OCW1の設定内容は、マスクレジスタIMRに格納したい値そのものになる。
0 はマスクの解除。1 はマスクを示す。

### OCW2
 7 6 5 4 3 2 1 0
┌───────────────┐
│R S E 0 0 L L L│
└───────────────┘

R ... ローテーションビット(あるデバイスが割り込みを受け付けられた後、割り込み優先度をローテションさせるためのビット
S(SL) ... SeLectionビット(ビット0-2のLビットで指定した優先度に変更する
E ... 割り込み終了コマンド(EOI)として動作
L ... SLビットが 1 のとき、現在の割り込み優先度を変更

EOIコマンドの例
```
outPortByte(0x20, 0x20) /* コマンドレジスタに00100000bを書き込む */
outPortByte(0xA0, 0x20);

## 8259Aあれこれ
8259Aには、コマンドレジスタ、ステータスレジスタ、割り込み要求レジスタIRR、割り込み中レジスタISR、割り込みマスクレジスタIMRがある。

### 割り込み要求レジスタ
割り込み要求レジスタは周辺デバイスが割り込みを要求しているかどうかを示すレジスタ。マスタ、スレーブごとの 1 ビットが各レジスタに対応している。

### 8259Aのポートアドレスのマッピング

0x20 ... マスタPICのコマンドレジスタとステータスレジスタ
0x21 ... マスタPICの割り込みマスクレジスタとデータレジスタ
0xA0 ... スレーブPICのコマンドレジスタとステータスレジスタ
0xA1 ... スレーブPICの割り込みマスクレジスタとデータレジスタ

## ハンドラの処理まとめ

### 現在実行中のプログラムの特権レベルよりゲートディスクリプタの特権レベルの方が低い場合

1. TSSディスクリプタに記述されているセグメントセレクタとスタックポインタに切り替え、現在実行中のスタックセグメントセレクタレジスタSSとスタックポインタSPをPUSHする
2. 次に、CPUは切り替えたスタック上に現在実行中のEFLAGS、CS、EIPをPUSHする
3. 例外の場合、エラーコードが切り替えたスタック上にエラーコードがPUSHされている

### 現在実行中のプログラムの特権レベルとゲートディスクリプタの特権レベルが同じ場合

1. CPUはEFLAGS、CS、EIPを現在の実行中のスタックにPUSHする
2. 例外の場合、エラーコードが切り替えたスタック上にエラーコードがPUSHされている
(1.がない)

### 例外から戻る命令

```
ired or iret
```

### IRQ の割り込みベクタ

ベクタ番号	IRQ	説明
0x20		IRQ0	タイマー
0x21		IRQ1	キーボード
0x22		IRQ2	スレーブPIC
0x23		IRQ3	シリアルポート2
0x24		IRQ4	シリアルポート1
0x25		IRQ5	ATシステム:パラレルポート2 | PS/2システム:予約
0x26		IRQ6	FDD
0x27		IRQ7	パラレルポート1
0x28		IRQ8	CMOS RTC(リアルタイムクロック)
0x29		IRQ9	CGA垂直トレース
0x2A		IRQ10	予約
0x2B		IRQ11	予約
0x2C		IRQ12	ATシステム:予約 | PS/2システム:AUXデバイス
0x2D		IRQ13	FPU
0x2E		IRQ14	HDD
0x2F		IRQ15	予約

